<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Blogging about stuffs</description>
    <link>http://feeds.feedburner.com/Dhclavie//</link>
    <atom:link href="http://feeds.feedburner.com/Dhclavie//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 10 Jan 2015 21:00:05 +0800</pubDate>
    <lastBuildDate>Sat, 10 Jan 2015 21:00:05 +0800</lastBuildDate>
    <generator>Jekyll v2.3.0</generator>
    
      <item>
        <title>30岁前的每一天</title>
        <description>&lt;pre&gt;&lt;code&gt;最近这周读了本《30岁前的每一天》，里面的内容促进了我去学习和改掉自己的一些坏习惯，更加让我明白早点为自己的未来去做计划，去安排每一天，去充实自己的生活，提高自己的能力。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.做好职业规划，就算现在的工作并不是自己喜欢的，也要专心去做，你能够学习到得东西绝对比你带着消极的情绪去工作时的多。&lt;/p&gt;

&lt;p&gt;2.如果想跨行跳槽，就一定要做好目标行业的学习准备，进入目标行业的圈子，熟悉后才进行，不能冒然进行跨行跳槽，这样90%只会失败告终。&lt;/p&gt;

&lt;p&gt;3.建立数字化的思维，如果想进行投资或者购买什么保险和投资基金，必须要罗列出表格进行收益比较，只有这样，你才能够完全明白和掌握自己的金钱是如何增长的。&lt;/p&gt;

&lt;p&gt;4.职业规划的三个步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1].我能做什么
[2].这个职业的晋升路径是怎样的
[3].我还能再做些什么
首先要对自己了解，明白自己能够做什么，然后对有兴趣从事的职业的了解，明白这个职业的上升路径是什么，最好就是寻找两者的差距，并想办法弥补。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.提高财商的几个方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1].看书
[2].找行业内人士交流（投资交流会之类的）
[3].咨询有实际经验的人
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.4类人&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1].收入完全依赖薪水的，处于雇员象限
[2].能够脱离打工境界，可以利用专业技能自己为自己打工的人处于自由工作者象限
[3].有一个小店，有3，4个员工，但每天还需要进行进货烧菜的老板，处于自由工作者象限
[4].拥有一个无需自己过多参与就可以自由运转的企业，处于企业家象限，能够财富自由
1.2.3两点的人无法达到财富自由。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.投资或者平时生活中，不要轻易相信结论，而要思考一个人说话的逻辑，保持独立的思考（这是投资理财的基本东西）&lt;/p&gt;

&lt;p&gt;8.一个人的时间花在什么地方，是可以看得出来的&lt;/p&gt;

&lt;p&gt;9.想要走上财富自己之路，走上投资创富的道路，首先要能够有积蓄开始投资，这是第一步，要是没有本金的话，投资技能也是没有什么意义。&lt;/p&gt;

&lt;p&gt;10.千万不要每一月花剩多少拿来储蓄，而一定要制定严格的纪律，先把钱储蓄起来，剩下的拿来花销，消费的欲望是无止境的，适当控制这种欲望，是走上财富自由之路的最重要的关键点。&lt;/p&gt;

&lt;p&gt;11.不要以为自己比别人聪明。&lt;/p&gt;

&lt;p&gt;12.在投资的世界里，不明白的事千万不要去做，不懂不可怕，不懂装懂才最糟糕。弄明白投资背后的逻辑，精心计算风险和收益，用知识和耐心，才可能换回最后的收获。&lt;/p&gt;

&lt;p&gt;13.把工作任务分割成30分钟左右是比较适合的。而在工作与工作的间歇，一定要休息，为下一次进入工作状态打好基础。&lt;/p&gt;

&lt;p&gt;14.重视休息，适当运动，才能有足够的能量保持注意力的高度集中。&lt;/p&gt;

&lt;p&gt;15.计划不明确，就无法制订明确的行动步骤，也就很容易使得行动变成空中楼阁。明确计划，日起有功，可以参考SMART原则进行规划：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Specific，具体的，指目标应该非常明确，定义不应该模糊，应该有数字限定
Measurable，可量化，能够把目标进行细分，分配到每一天
Attainable，可达到，目标应该是可以完成的
Relevant，关联性，应该这个目标和你的其他目标的最终目的是一致的
Time-based，有截止日期的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16.安排详细计划，避免懒惰，把计划细化为每天的工作，最重大的意义，就是每天都会有一次检查的过程。在这个过程中，会通过书面的方式，对自己的“3分钟热度”问题进行监督和检查，并且根据实际的执行情况提出改进意见，帮助自己更好地完成任务。&lt;/p&gt;

&lt;p&gt;17.实际上，如果能够把要执行的任务标准化，能够照单行事，不用多想，或者可以降低抗拒心理，让行动得以持续。&lt;/p&gt;

&lt;p&gt;18.将麻烦的事彻底标准化，把所有的行动细节都予以规定，让自己的行动可以按部就班，不需要思考，这个道理在工作上也非常适用，繁琐费力的事情，通过工具，定义流程进行标准化，这样效率就提高，也避免重复的思考。&lt;/p&gt;

&lt;p&gt;19.走在奔向梦想的道路上，要积累正能量，抗击负能量，要迎接各种挑战，要改变各种陋习，要对事业、学习、财富和爱情都有所规划。而这一切，需要一个实实在在的工具来帮助你实现，否则，一切梦想都只能是空中楼阁。&lt;/p&gt;

&lt;p&gt;20.当文字要被记录下来的时候，人就会对被记录的文字进行思考，书写是自己与自己的对话，也是对信息的重新整理和思考&lt;/p&gt;

&lt;p&gt;21.“大象”是盲目的，追求短期利益的，喜欢享受的。正如你每次面对困难的任务就会害怕和逃避，正如你虽然知道自己在减肥却无法抵制那块巧克力蛋糕，这就是那头“大象”在起作用。而作为“骑象人”，作为一个理性的你，对待困难应该迎难而上，面对诱惑应该坚决抵制。为梦想作计划，为了长远的利益克服眼前的惰性，这些都是理性的大脑才会做的事，记事本能够呼唤出理性的大脑，帮助你战胜冲动的“大象”。&lt;/p&gt;

&lt;p&gt;22.时间用在什么地方，是看得到的。&lt;/p&gt;

&lt;p&gt;23.适用笔记本安排计划，开始的时候，对自己要求低一点是应该的。但是有一点不要忘记，就是一定要坚持。&lt;/p&gt;

&lt;p&gt;24.每天坚持，是为了改变生活的惯性。每一种习惯都是有惯性的，尤其是在开始阶段，阻力非常大的时候。如果能每天在固定的时间坚持，就能冲破这种阻力，形成良好的习惯。&lt;/p&gt;

&lt;p&gt;25.有时候，行动甚至应该在思维之前，瞻前顾后地考虑太多是没办法做好事情的，先做了再说，贯彻“立即行动”的精神，在行动的过程当中不断总结经验，调整方向，才是最好的战略。&lt;/p&gt;

&lt;p&gt;26.从时间记录开始，到以后越来越进阶的“事先预习”和“每日反省”，都需要随时检查记事本，把每一点滴的进步和思想记录下来，以对抗大脑的“遗忘机制”和“短期记忆”。因为“时间记录”的目标是为了今后做类似事件的对比，以便提高工作效率。如果没有整个事件的“时间记录”，就没有起点的标准，以后也很难做到提高。&lt;/p&gt;

&lt;p&gt;27.越高的房子，越需要坚实的基础；越高大的树木，越需要细密繁杂的根须。所有为了基础作的努力，都是为了今后会有更高的大楼和更繁茂的枝叶。&lt;/p&gt;

&lt;p&gt;28.PDCA循环就是先制订计划，然后按照计划实施，最后通过检查和总结来反思从计划到实施的差距，最后把自己的体会放到下一次实施中去。PDCA循环可以是一日的，也可以是一周的、一个月的、一年的。&lt;/p&gt;

&lt;p&gt;29.“一日PDCA循环”从每日计划开始，实际上，计划应该是由大及小的，应该先制定你的远期目标，远期目标一般超过5年，例如本书一开始就提出的你的梦想就是一个长期梦想。然后根据你的远期目标再制定你的中期目标，大约是1～5年。然后再根据中期目标来制定短期目标，直至将目标划分为每日的行动。&lt;/p&gt;

&lt;p&gt;30.人始终是根据任务的时间期限来调整工作速度的。&lt;/p&gt;

&lt;p&gt;31.立即去做你目前计划中的事，哪怕只有5分钟。有些时间段看似很少，但其实是一个勇敢的开始，它会让你燃烧起工作的斗志。&lt;/p&gt;

&lt;p&gt;32.建议每天应该给自己一个特定的时间。例如每天的晚上，通过回顾一天的任务执行情况，来审视哪些任务没有很好地按照计划完成，并且分析造成这种问题发生的原因。每天应该给自己留出10分钟时间，在记事本的所有日程下面写上“当日反省”，然后思考当天在工作中出现的各种失误，把它写下来。在每天写完“当日反省”和“改进方法”之后，还应该写的就是“当日学习”部分。这是用以总结你在每天的工作学习中，从外部得到的可能有助于你自己提高的小技巧、小方法、小知识。&lt;/p&gt;

&lt;p&gt;33.学会利用笔记本，因此你的记事本，就是只属于你自己的经验库，所有对你自己的失误的记录、有效的改进方法，以及对你而言有意义的学习内容，都是只属于你的。通过观察自己，通过对自己的“一日三省”以及从生活点滴中学习到的技巧和方法，让自己每天都朝着梦想的方向前进。要在记事本上留出专门的位置给“重要事件”，只要是你认为非常重要的事件，就用红笔记录在上面，并且为此预留充分的时间，并把准备的内容写在这个页面上。&lt;/p&gt;

&lt;p&gt;34.人总是希望别人以为自己从来都是这么牛逼的。&lt;/p&gt;

&lt;p&gt;35.自信，就是不论是金融危机还是公司裁员，都不能剥夺我的财富以及投资能力。&lt;/p&gt;

&lt;p&gt;36.书读过了，拿起来再读一次，你会明白的更多。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;后面要做得：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.TN记事本，规划每一天，每周计划，每月计划，每年计划，3-5年计划。
2.制定储蓄计划，做好投资准备
3.改变观念，改坏习惯，战胜懒惰
4.坚持，坚持，再坚持。
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sun, 11 Jan 2015 04:59:12 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/before_30_years_old</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/before_30_years_old</guid>
        
        
        <category>plan</category>
        
        <category>samueldeng</category>
        
        <category>dhclavie</category>
        
      </item>
    
      <item>
        <title>习惯的力量</title>
        <description>&lt;p&gt;周末读了一本叫《习惯的力量》的书，整体觉得很一般，平时工作比较忙，不知不觉养成了很多坏习惯，例如衣服经常忘记洗，说白了就是懒，到周末一大堆大堆的洗衣服，做事情老拖，想改变，然后无意看见这本书，就读了下，下面记录了下觉得有启发的东西。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;个人习惯&lt;/h4&gt;

&lt;p&gt;习惯改变性格，性格改变人生，成功的人生，都从一个好习惯开始。&lt;/p&gt;

&lt;p&gt;渴求驱动习惯。&lt;/p&gt;

&lt;p&gt;适当的奖赏可以让行为持续进行成为习惯。&lt;/p&gt;

&lt;p&gt;如果你想减肥，就应该了解自己的习惯，看看为什么每天休息时，自己都会去办公室找点吃的。&lt;/p&gt;

&lt;p&gt;如果想改变一个习惯，你必须找另一个惯常行为替代，而且当你和一个群体一起努力时，改变的成功性会大大提高，
信仰是必要的，而且它是在群体中培养出来，即使群体只有2个人，结果也是一样的。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;组织机构的习惯&lt;/h4&gt;
&lt;p&gt;核心习惯：最重要的习惯&lt;/p&gt;

&lt;p&gt;破坏一个习惯，观察整个公司会因此连带出现什么样的变化&lt;/p&gt;

&lt;p&gt;你不能命令人们去改变，人大脑并不是那样工作的，所以我决定先集中在一件事情上，如果我一开始先破坏某件事的习惯，它就会扩展到整个公司。&lt;/p&gt;

&lt;p&gt;一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，他们就是核心习惯。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;干货&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;全书觉得最有用的就是最后的“读者实践指南”。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变可能不是很快，而且也不容易，但只要愿意付出时间去坚持，几乎所有习惯都可以改变。&lt;/p&gt;

&lt;p&gt;理解框架&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.找出惯常行为
2.用各种奖赏进行试验
3.将暗示隔离出来
4.制订计划
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然改变习惯很难，但这个框架是一个好的开端。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;自律+坚持&lt;/h4&gt;

&lt;p&gt;想要改变现在的生活，想要更加靠近自己的梦想，必须得改变自己的某些坏习惯，平时要严格自律，当然，坚持也是必须得。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Nov 2014 00:42:23 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/the_power_of_rabit_cn</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/the_power_of_rabit_cn</guid>
        
        
        <category>post</category>
        
        <category>习惯</category>
        
      </item>
    
      <item>
        <title>Google V8引擎的安装和使用</title>
        <description>&lt;p&gt;最近写的一个模块需要引用Google V8这个库，下面介绍如何安装和使用。（必须翻墙）&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;根据参考资料1，2，用git下载v8&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/v8/v8-git-mirror
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入这个目录，切到master分支，下周依赖库（必须翻墙）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd v8-git-mirror
git checkout master
make dependencies  // 下载依赖库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果成功把依赖都编译好了可以跳过下面这不，我是先在makefile里面把依赖库一个个下载回来再放在合适的目录
,makefile 里面列出的依赖库如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;493     svn checkout --force http://gyp.googlecode.com/svn/trunk build/gyp \
494         --revision 1831
495     if svn info third_party/icu 2&amp;gt;&amp;amp;1 | grep -q icu46 ; then \
496       svn switch --force \
497           https://src.chromium.org/chrome/trunk/deps/third_party/icu52 \
498           third_party/icu --revision 277999 ; \
499     else \
500       svn checkout --force \
501           https://src.chromium.org/chrome/trunk/deps/third_party/icu52 \
502           third_party/icu --revision 277999 ; \
503     fi
504     svn checkout --force http://googletest.googlecode.com/svn/trunk \
505         testing/gtest --revision 692
506     svn checkout --force http://googlemock.googlecode.com/svn/trunk \
507         testing/gmock --revision 485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;东西准备好了，下面编译这个库，注意把ibrary=shared 参数加上，把它编译为so库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make native mode=debug library=shared -j2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定native会自动判断你当前系统的架构进行编译，-j2为指定使用2个进程进行编译加快编译速度,编译成功后在v8-git-mirror/out/native/lib.target目录下会出现下面几个文件，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rwxr-xr-x. 2 root root  2742392 11月  9 11:31 libicui18n.so
-rwxr-xr-x. 2 root root 12400430 11月  9 11:30 libicuuc.so
-rwxr-xr-x. 2 root root 12227393 11月  9 11:45 libv8.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式和一般的so一样（可以将so拷贝到系统lib目录或者指定LD_LIBRARY_PATH环境变量）.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;参考资料中的第三项，将提供代码（可能和下面的有所差别）保存为hw.cc&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;#include &amp;lt;v8.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a new Isolate and make it the current one.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isolate_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a stack-allocated handle scope.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;HandleScope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a new context.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;  		&lt;span class=&quot;c1&quot;&gt;// Enter the context for compiling and running the hello world script.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a string containing the JavaScript source code.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewFromUtf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;#39;Hello&amp;#39; + &amp;#39;, World!&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Compile the source code.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Run the script to get the result.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Convert the result to an UTF8 string and print it.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Utf8Value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;   		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -I/root/sources/v8-git-mirror/include hw.cc -lv8 -lpthread -o hw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./hw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello，world！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就算是使用了v8这个库了，里面的代码理解需要了解v8的基本数据结构和原理，上面例子虽然就几行代码，但五脏俱全，算是个小小的将js代码进行解释的程序了。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考资料&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;[1] https://code.google.com/p/v8-wiki/wiki/UsingGit
[2] https://github.com/v8/v8-git-mirror
[3] https://developers.google.com/v8/get_started
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 10 Nov 2014 01:21:11 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/google_v8_install</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/google_v8_install</guid>
        
        
        <category>post</category>
        
        <category>google</category>
        
        <category>v8</category>
        
      </item>
    
      <item>
        <title>关于Node Buffer对象</title>
        <description>&lt;p&gt;最近写一个专门为新项目写一个nodejs的c++模块去解释protobuf的消息（名字叫node_pd哈，后面写文章介绍），为何要重新造轮子？因为npm上面都TM没有合适的，试用了两个，一个不支持extension，一个extension解释出问题，然后，然后就打算自己写了，目前准备完成了，90%吧，可以正常在C++和javascript之间解释和生成消息，呃。。。，说了些和主题木有关系东东，算是作为背景吧。&lt;/p&gt;

&lt;p&gt;Node提高的buffer对象，实际上是一个二进制数组，占用的内存使用堆分配，没有使用V8的垃圾回收机制。这个对象所在的模块由node启动的时候加载，不需要required，可以直接使用，一般使用buffer对象来存储二进制数据，多用于网络服务作为缓冲区，好吧，我承认这几句话很废。&lt;/p&gt;

&lt;p&gt;node的buffer对象使用的内存不在v8引擎的管理，是存在于v8内存管理之外的内存空间，代码头文件解释是这么说的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A buffer is a chunk of memory stored outside the V8 heap, mirrored by an object in javascript.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看下代码：node-v0.10.32/src/node_buffer.cc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;111 Buffer* Buffer::New(char *data, size_t length,
112                     free_callback callback, void *hint) {
113   HandleScope scope;
114
115   Local&amp;lt;Value&amp;gt; arg = Integer::NewFromUnsigned(0);
116   Local&amp;lt;Object&amp;gt; obj = constructor_template-&amp;gt;GetFunction()-&amp;gt;NewInstance(1, &amp;amp;arg);
117
118   Buffer *buffer = ObjectWrap::Unwrap&amp;lt;Buffer&amp;gt;(obj);
119   buffer-&amp;gt;Replace(data, length, callback, hint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看最后一句，以及下面的最后一句，确实是在系统堆中分配，不在v8的管理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;162 void Buffer::Replace(char *data, size_t length,
163                      free_callback callback, void *hint) {
164   HandleScope scope;
174   length_ = length;
175   callback_ = callback;
176   callback_hint_ = hint;
177
178   if (callback_) {
179     data_ = data;
180   } else if (length_) {
181     data_ = new char[length_];
182     if (data)
183       memcpy(data_, data, length_);
189   handle_-&amp;gt;SetIndexedPropertiesToExternalArrayData(data_,
190                                                    kExternalUnsignedByteArray,
191                                                    length_);
192   handle_-&amp;gt;Set(length_symbol, Integer::NewFromUnsigned(length_));
193 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且会将内存指针设置在handle_这个v8对象（这是个持久型对象）上面,说白了就是把地址放在这个对象中，。当需要在引用这个buffer对象的数据时，在v8环境中就可以根据这个handle_去获取数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;75   static inline char* Data(v8::Handle&amp;lt;v8::Value&amp;gt; val) {
 	76     assert(val-&amp;gt;IsObject());
 	77     void* data = val.As&amp;lt;v8::Object&amp;gt;()-&amp;gt;GetIndexedPropertiesExternalArrayData();
 	78     return static_cast&amp;lt;char*&amp;gt;(data);
 	79   }
 	80
 	81   static inline char* Data(Buffer *b) {
 	82     return Buffer::Data(b-&amp;gt;handle_);
 	83   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便说下，buffer的对象最大的理论存储空间为0x3fffffff，也就是1G空间。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;66 class NODE_EXTERN Buffer: public ObjectWrap {
 	67  public:
 	68   // mirrors deps/v8/src/objects.h
 	69   static const unsigned int kMaxLength = 0x3fffffff;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;关于使用&lt;/h4&gt;
&lt;p&gt;如果想在node c++模块中使用buffer对象，需要引入buffer和node对象wrapper的头文件（node.h，node_buffer.h，node_object_wrap.h）。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;后话&lt;/h4&gt;
&lt;p&gt;详细使用待研究。。。。。&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Nov 2014 06:18:00 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/node-buffer</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/node-buffer</guid>
        
        
        <category>node</category>
        
        <category>c/c++</category>
        
        <category>buffer</category>
        
        <category>v8</category>
        
      </item>
    
      <item>
        <title>大型网站架构基础</title>
        <description>&lt;pre&gt;&lt;code&gt;上周读了《大型网站技术架构》这本书，总体来说，里面很多重复的内容，而且讲的不够深入，很多都是简单介绍一下，大型网站架构也不是一开始就设置的多么高级，也是由于网站性能，可用性等满足不了当前的情况进而对站点架构进行升级，改正的过程，书里面讲到几个平时比较混淆的概念，这篇就作为读书比较记录下书中想过概念和技术。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;大型网站架构普遍的演变过程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.应用程序和DB在同一台服务器
2.应用程序和DB分离
3.应用程序和DB之间假如缓存层，可以为本地缓存或者为远程缓存（memcached，redis等）
4.使用lVS+应用程序集群替换单个应用程序改善网站的并发处理能力
5.数据库改造，数据库读写分离（主-从模式）
6.在LVS前面，增加反向代理和CDN加速网站响应速度
7.数据库改造，分库，分表，建立分布式数据库集群
8.应用程序集群升级为分布式服务
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;大型网站架构模式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.分层：网站分为应用层，服务层，数据层
2.分割：业务分割部署，功能分割为多个服务
3.分布式：
		&amp;lt;1&amp;gt;分布式应用和服务：应用和服务模块分布式部署
		&amp;lt;2&amp;gt;分布式静态资源，网站的css，js和图片进行独立部署
		&amp;lt;3&amp;gt;分布式数据和存储，数据分布式存储
		&amp;lt;4&amp;gt;分布式技术，hadoop和MapReduce进行批处理计算，分散计算
		&amp;lt;5&amp;gt;分布式配置和锁，zookeeper
4.集群：无状态服务集群部署
5.缓存，加快处理速度，例如，CDN，反向代理，本地缓存，分布式缓存
6.异步，加快响应，消除并发高峰
7.冗余，冷备份和热备份
8.自动化，部署自动化
9.安全，防XSS和SQL注入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;软件架构关注的几个要素：性能，可用性，伸缩性，扩展性，安全性。&lt;/h4&gt;

&lt;h4 id=&quot;section-3&quot;&gt;性能&lt;/h4&gt;
&lt;p&gt;主要使用响应速度作为指标，可以使用页面压缩，合理页面布局，减少COOKIE传输，CDN，反向代理，缓存，SQL优化，索引，读写分离，集群，异步等手段进行各层次优化。&lt;/p&gt;

&lt;p&gt;Web前端优化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.减少http请求数量（压缩js，css，和图片合并）
2.浏览器缓存
3.启用压缩，服务器对文件进行压缩
4.css放页面head，js放body里面
5.减少cookies传输
6.CDN加速
7.反向代理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后端服务器优化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.分布式缓存，memcache，redis
2.代码异步，无状态
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;可用性&lt;/h4&gt;
&lt;p&gt;主要使用可用时间作为指标，可以使用热备份，主从DB，无状态应用集群部署等手段提高。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;伸缩性&lt;/h4&gt;
&lt;p&gt;衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器，加入新的服务器后，是否可以提供和原来服务器无差别的服务，集群中可容纳的总的服务器数量是否有限制。
应用服务器集群，尽量让服务无状态以通过LVS不断加入服务器
缓存服务器集群，加入新的服务器会领缓存失效，使用一致性hash最大限度减少失效的节点（虚拟节点）&lt;/p&gt;

&lt;p&gt;伸缩性设计&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.http重定向负载均衡
2.DNS域名解析负载均衡
3.方向代理
4.IP负载均衡
5.数据链路负载均衡（lvs）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-6&quot;&gt;扩展性&lt;/h4&gt;
&lt;p&gt;衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现在产品透明无影响，不需要修改或者修改很少业务功能就可以上线新产品，不同产品之间尽量减少耦合，主要手段是使用事件驱动架构和分布式服务。&lt;/p&gt;

&lt;p&gt;利用分布式消息队列降低系统耦合性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.事件驱动架构（libevent，node等）
1.分布式消息队列（rabbitmq等）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-7&quot;&gt;安全性&lt;/h4&gt;
&lt;p&gt;是否能保护网站重要数据不被窃取。&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Oct 2014 08:37:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/web_server_architecture</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/web_server_architecture</guid>
        
        
        <category>post</category>
        
        <category>web</category>
        
        <category>architecture</category>
        
      </item>
    
      <item>
        <title>Rework2 - office not required (重来2)</title>
        <description>&lt;p&gt;最近看rework - office not required 这本书，里面介绍了几个远程工作的工具和建议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.远程工作相互重叠的时间，37signals建议4小时。：）
2.屏幕共享软件：
	MAC中的quicktime player 屏幕录制
	www.join.me
	http://www.gotomeeting.com/
	http://www.webex.com/

3.资料共享
	dropbox，github，共享日历，共享工作任务todo list
	http://www.salesforce.com/ 或者 https://highrisehq.com/ 跟进销售
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是否远程工作，在每天结束之后，问问自己，今天有木有好好工作？这个问题可以让你内心得到解脱，如果你迅速地答出，是的，你就可以心满意足地停下来，就算这项工作木有完成，这也许就是一种心里暗示，我有时候也会感受到，确定是有效果的。&lt;/p&gt;

&lt;p&gt;高效获取市场的几个策略&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.在销售阶段，要让潜在客户很早就知道你们不在同一个地方，信任需要在一开始的时候就建立起来。
2.在客户开口索要你的背景资料之前，就主动给他们，一上来就让客户知道，你没什么隐瞒的。
3.经常把工作进度拿给他们看，客户会焦虑，而这是减轻焦虑的好方法。
4.让客户很容易就找到你，既然你们没法面对面，那你最好迅速地回电话，邮件和即时信息。
5.要让客户参与进来，及时掌握进度，让客户感受到，这也是他们的项目。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了顺利地实现远程工作，你的写作能力和沟通能力一定要过硬，熟练掌握英文是关键。&lt;/p&gt;

&lt;p&gt;优秀的远程员工就是优秀的员工。&lt;/p&gt;

&lt;p&gt;把一天分成几个阶段，阅读最新的资讯，协作，专心工作，处理邮件，查看行业新闻等。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Oct 2014 09:28:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/rework2_remoting_work</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/rework2_remoting_work</guid>
        
        
        <category>post</category>
        
        <category>reading</category>
        
      </item>
    
      <item>
        <title>一致性Hash</title>
        <description>&lt;pre&gt;&lt;code&gt;去年工作的时候听大智慧的架构师的演讲，第一次听到一致性hash这个名词，当时没听明白，
后面工作没联系到这个东西，后来也没去追查了，但了今年，听存储的同事的演讲，
也听到这个名词，然后就有了这篇文章。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;背景&lt;/h4&gt;

&lt;p&gt;一般的分布式缓存系统是这样设计的，有好几台内存比较大的服务器作为缓存服务器，
假如3台，node1，node2，node3，业务程序需要把频繁访问的热点数据存储在
缓存服务器中以减少对下层DB的压力，这时，假如写数据（“test”，”{a:1,b:2}”）
, 缓存系统内部的过程是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.向缓存系统的路由组件根据hash算法，算出key（也就是text）的hash值，
然后用这个hash值余3的出一台缓存服务器，假如这里得到node2
2.缓存系统将这个路由信息记录下来，以便下次访问
3.返回给业务程序node2这个节点的信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，业务程序就把这个数据往node2这个节点写（至于用什么协议，可以自定，
假如Memcached，redis等），下次需要读取数据的时候，读操作过程简单可以认为是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.根据key从缓存系统的路由组件获取这个key对应的node节点信息
2.返回给业务程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以马上知道是node2这个节点，立刻进行读操作，无需再访问DB，起到加速的作用。
但后面业务发展迅猛，需要增加了1台缓存服务器，这时，缓存服务器的数量就变成4了，
路由计算也需要使用4昨晚被除数重算计算hasn值，这样前面三台缓存服务器的路由信息就
起不到原来的左右，所有数据都会走到DB去访问并重新缓存，起不到原来需要的效果。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;那有什么方法可以处理尼？&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;本质上就是需要在新增服务器的时候尽量减少对已上线服务器的影响，也就是尽量
减少路由信息失效的范围
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;hashconsistent-hashing&quot;&gt;一致性hash（Consistent hashing）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;答案就是引入一致性hash算法来做路由计算，先构造一个0-2的32次方的环，然后
将缓存服务器id（假如cache A）根据hash算出一个数值，这个数值也是0-2的32次方
的范围，并投射在这个环上，类似，cache B 和cache C同样用这个方式投射到这个大环
上面，当业务程序需要把写缓存数据时，讲key进行hash得到一个0到2的32次方之间的
hash值（key 1），并投射到这个环上面，然后顺时针找到cache A，因此就返回cache A
的信息，这样的做法的好处时，下次有新服务器加入时，例如cache D，计算得出的hash值
投放到cache A 和 cache B直接，那么原来在cache A到cache b直接的某一部分
（cache A到cache D的这部分）路由信息会失效，而其他的别的路由信息都可以继续
正常使用，但这样由于新增的服务器减低了cache B的负载（一部分负载都到cache D了），
而cache A和cache C的负载还是很高，这样所有服务器的负载就很不平衡，因此我们采取
下面的方式进一步优化这个方案。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://feeds.feedburner.com/Dhclavie/images/Consistent_hashing.jpg&quot; alt=&quot;Consistent_hashing&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;虚拟节点&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;上面提到的不足的主要原因是因为节点数量在比较少的情况下才会发生的，因此下面的
解决方案是增加缓存服务器的节点数量，但服务器非常昂贵，增加是非常有限的，因此
现在的方案是把一个物理节点虚拟为多个虚拟节点，如下图，新增服务器时，都按照这样
的方式，把虚拟节点映射到hash环上面去，这样hash key的值分布就会比较均很到散落
在这些物理服务器上面去。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://feeds.feedburner.com/Dhclavie/images/Consistent_hashing_virtual_node.png&quot; alt=&quot;Consistent_hashing&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Oct 2014 08:40:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/consistent_hashing</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/consistent_hashing</guid>
        
        
        <category>post</category>
        
        <category>consistenthashing</category>
        
        <category>cache</category>
        
      </item>
    
      <item>
        <title>Apple Swift Language Base</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.变量和常量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let定义常量，var定义变量	
赋值市会隐含定义类型，swift不会隐含修改变量的类型，需要修改，必须明确指定。
字符串拼接使用加号（+），或者直接在字符串字面量前面使用\() 
创建数组或者字典使用[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.控制流&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;条件控制 if switch， switch 里面的case无需明确break，默认会break，但必须有default
循环使用for, for in , while , do while
使用..&amp;lt; 或者...在循环中指定一个范围，后者为包括
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.函数和闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;函数使用func定义，可以返回多个值，函数调用使用括号，参数必须指定类型
func(a:Int  , b:Int ) -&amp;gt; String {} 接受2个int类型，返回一个字符串
函数参数可以为可变参数，在类型后面加...
函数体可以继续定义函数
在swift，函数本质上是一个简单的闭包
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;4.对象和类&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class 后面接类名定义类
使用类名+括号创建对象，调用对象方法使用.操作符
构成函数使用init定义
析构函数使用deinit定义
在类函数里使用self访问对象成员
继承使用:
重写子类方法使用override指定
属性可以具有set，get方法，set方法默认传递的参数名称为newValue，可以修改，在set后面加括号指明参数名称即可，无	需指定类型
可以给属性添加willSet和didSet指定赋值前或者赋值后的逻辑
可以配合？指定选项变量，当对象为nil时，语句后面的操作不会执行
选项变量为在变量类型前面加？，定义为选项变量，后面引用都比较有？号
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;5.结构和枚举类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;enum定义枚举类型，可以为enum类型提高函数，但这里的枚举类型不需要值，c/c++中的枚举类型本质为unsigned，
但这里的枚举类型为一个名称，我想应该是一种对象吧。可以在里面定义方法，并进行访问，而且枚举类型和类不一样，
不需要实例化。

struct定义结构，结构可以定义构造函数和方法，属性，但和类不一样的是结构使用值传递，类使用引用传递，这个
和传统语言类似
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;protocolsextensions&quot;&gt;6.协议和扩展（protocols，extensions）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用protocol定义一个协议,协议里面的只可以写方法声明或者属性声明，不能写body
mutating func定义个协议方法，也就是定义一个接口吧，继承者必须实现。	使用extension扩展一个存在的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;generics&quot;&gt;7.Generics（怎么叫？应该是模板吧）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用&amp;lt;&amp;gt;指定类型，具体使用case by case
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 19 Oct 2014 08:53:20 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/apple_swift_language_base</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/apple_swift_language_base</guid>
        
        
        <category>post</category>
        
        <category>swift</category>
        
        <category>apple</category>
        
      </item>
    
      <item>
        <title>Base Javascript</title>
        <description>&lt;p&gt;1.访问一个不存在的变量或者没有赋值的变量，得到undefined&lt;/p&gt;

&lt;p&gt;2.null变量不是undefined，这个变量有值，是一个特殊的object，值为为null&lt;/p&gt;

&lt;p&gt;3.任何不属于number，string，boolean，undefined，null的都为对象object（function也为对象）&lt;/p&gt;

&lt;p&gt;4.typeof 操作可以返回变量的类型,用字符串表示，如“string”&lt;/p&gt;

&lt;p&gt;5.NaN is a special value that is also a number，Nan也是一个数值&lt;/p&gt;

&lt;p&gt;6.下面的情况导致false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The empty string “”&lt;/li&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;The number 0&lt;/li&gt;
  &lt;li&gt;The number NaN&lt;/li&gt;
  &lt;li&gt;The Boolean false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7.函数没有明确返回值，默认返回undefined&lt;/p&gt;

&lt;p&gt;8.函数里面包含一个默认的数组arguments（其实是一个object）包含所有的参数&lt;/p&gt;

&lt;p&gt;9.if内定义的变量外层可以访问，函数内定义的变量外层不能访问&lt;/p&gt;

&lt;p&gt;10.Variable hoisting, 函数内定义的和外层变量同名的变量，定义会被提升到函数开始，因此，一进入函数内，和函数内部同名的外部变量瞬间被秒杀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When your JavaScript program execution enters a new function, 
all the variables declared anywhere in the function are 
moved (or elevated, or hoisted) to the top of the function. 
This is an important concept to keep in mind. Further, 
only the declaration is hoisted, meaning only the presence of 
the variable is moved to the top. Any assignments stay where they are.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;      	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;     	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变成:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;      	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// same as: var a = undefined;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;11.即刻执行的函数不能被执行第二次！！！&lt;/p&gt;

&lt;p&gt;12.函数可以被作为参数转递&lt;/p&gt;

&lt;p&gt;13.闭包说白了就是将变量作用域的范围进行扩大&lt;/p&gt;

&lt;p&gt;14.给对象设置属性时，属性的名字可以为下面形式：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;occupation&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;occupation&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;15.在javascript中如果你想使用类似hash的数据结构，那么可以使用object&lt;/p&gt;

&lt;p&gt;16.创建“new 函数名称”的形式可以创建一个对象，并且会调用这个函数，而这个函数也就成为了这个对象的构造函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance_dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;keke&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17.每个object实例都有一个constructor属性，指向这个实例的构造函数&lt;/p&gt;

&lt;p&gt;18.函数有一个length属性指出期望的参数个数（也就是参数列表的个数）&lt;/p&gt;

&lt;p&gt;19.每个函数都有一个prototype属性，这个属性指向一个对象，每个从这个函数构造出来的对象都继续了这个prototype所指向的对象的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;All objects created with this function keep a reference 
to the prototype property and can use its properties as their own
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20.function对象的call和apply方法可以用别的对象作为调用实例进行使用，也就是可以使用别的实例作为内部的this引用进行使用，功能一样，但传递的参数不一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;These methods also allow your objects to &quot;borrow&quot; methods 
from other objects and invoke them as their own. 
This is an easy and powerful way to reuse code.

some_obj.someMethod.apply(my_obj, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
   	some_obj.someMethod.call(my_obj, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21.当对象是new 函数的方式构造出来的，prototype上面的属性才会依附到this上面，单纯使用函数调用，prototype上面的属性不会依附到this对象，因此，通过在prototype上面添加属性的方式，可以给实例进行属性添加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Adding methods and properties to the prototype property 
of the constructor function is another way to add functionality 
to the objects this constructor produces.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;22.属性查找时是按照prototype链往上查找。&lt;/p&gt;

&lt;p&gt;23.prototype依附的属性会在new操作之后拷贝到对象上面，对对象属性的修改不会影响到prototype上面的属性。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Oct 2014 07:40:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/Javascript-base</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/Javascript-base</guid>
        
        
        <category>post</category>
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>Node Module</title>
        <description>&lt;p&gt;这篇文章介绍如何编写Node模块，node模块遵循commonjs标准，实现起来非常简单，下面简单实现一个maths的模块, 在macosx下编写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim maths.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在maths.js里面写入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.add = function(a, b) {
	return a+b;
}
exports.sub = function(a, b) {
	return a-b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到代码里面使用了exports导出两个函数，在node里面使用exports或者module.exports导出模块里面的功能，现在，已经完成了maths模块，下面试着使用下这个模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在相同目录下创建app.js，然后写入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var maths = require(&quot;/maths.js&quot;);
console.log(maths(1,2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 但注意到我们引入这个模块的形式指明了路径，如何才可以使用npm安装我们自己编写的模块？现在，我们创建一个maths的目录：

mkdir maths
cd maths
mv ../maths.js index.js
vim package.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在package.json里面写入下面参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  		&quot;name&quot;: &quot;maths&quot;,
  		&quot;version&quot;: &quot;0.0.1&quot;,
  		&quot;private&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意version参数必须是三位的，之前我使用了2位的，模块没有包装成功，最后创建README.md文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo maths function add and sub! &amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我们使用下面命令包装模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/maths/ npm pack
	maths-0.0.1.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块已经打包完成，下面试着用npm安装这个模块到我们的项目里面（下面创建一个项目目录，进行模块安装）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir modtest
cd modtest
npm install ~/Project/maths/maths-0.0.1.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在模块已经安装到我们的项目里面，可以查看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ npm install ~/Project/maths/maths-0.0.1.tgz
	maths@0.0.1 node_modules/maths
 ~/Project/modtest/ ls
	node_modules
 ~/Project/modtest/ ls node_modules
	maths
 ~/Project/modtest/ ls node_modules/maths
	README.md    index.js     package.json
 ~/Project/modtest/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们试着来使用这个模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var maths = require(&quot;maths&quot;);
console.log(maths.add(1,2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ node app.js
	3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的一个模块完成拉 ：），但看见很多别的人模块里面导出功能是使用module.exports的，我们这里使用了exports，到底这两个有什么差别？看下面的例子,编辑文件test.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = &quot;xxxxxxxx&quot;;
exports.add = function(){
	console.log(&quot;add&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用这个文件时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = &quot;xxxxxxxx&quot;;
exports.add = function(){
      console.log(&quot;add&quot;);
}
                    
 ~/Project/modtest/ node app.js
	xxxxxxxx
	/Users/apple/Project/modtest/app.js:4
	test.add();
 		 ^
	TypeError: Object xxxxxxxx has no method &#39;add&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的test对象为一个string，没有add方法，再看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports.name = &quot;xxxxxxxx&quot;;
exports.add = function(){
	console.log(&quot;add&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入这个文件时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var test = require(&quot;./test.js&quot;);
console.log(test.name);
test.add();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ node app.js
xxxxxxxx
add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，我们可以得知，最终导出的是modul.exports上面的对象，attach在exports上面的对象最终会被attach到modul.exports上面，但前提是module.exports是一个对象。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Sep 2014 19:09:08 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/node-module</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/node-module</guid>
        
        
        <category>post</category>
        
        <category>node</category>
        
        <category>module</category>
        
        <category>javascript</category>
        
      </item>
    
  </channel>
</rss>
