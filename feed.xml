<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Blogging about stuffs</description>
    <link>http://feeds.feedburner.com/Dhclavie//</link>
    <atom:link href="http://feeds.feedburner.com/Dhclavie//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 23 Nov 2014 01:08:10 +0800</pubDate>
    <lastBuildDate>Sun, 23 Nov 2014 01:08:10 +0800</lastBuildDate>
    <generator>Jekyll v2.3.0</generator>
    
      <item>
        <title>习惯的力量</title>
        <description>&lt;p&gt;周末读了一本叫《习惯的力量》的书，整体觉得很一般，平时工作比较忙，不知不觉养成了很多坏习惯，例如衣服经常忘记洗，说白了就是懒，到周末一大堆大堆的洗衣服，做事情老拖，想改变，然后无意看见这本书，就读了下，下面记录了下觉得有启发的东西。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;个人习惯&lt;/h4&gt;

&lt;p&gt;习惯改变性格，性格改变人生，成功的人生，都从一个好习惯开始。&lt;/p&gt;

&lt;p&gt;渴求驱动习惯。&lt;/p&gt;

&lt;p&gt;适当的奖赏可以让行为持续进行成为习惯。&lt;/p&gt;

&lt;p&gt;如果你想减肥，就应该了解自己的习惯，看看为什么每天休息时，自己都会去办公室找点吃的。&lt;/p&gt;

&lt;p&gt;如果想改变一个习惯，你必须找另一个惯常行为替代，而且当你和一个群体一起努力时，改变的成功性会大大提高，
信仰是必要的，而且它是在群体中培养出来，即使群体只有2个人，结果也是一样的。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;组织机构的习惯&lt;/h4&gt;
&lt;p&gt;核心习惯：最重要的习惯&lt;/p&gt;

&lt;p&gt;破坏一个习惯，观察整个公司会因此连带出现什么样的变化&lt;/p&gt;

&lt;p&gt;你不能命令人们去改变，人大脑并不是那样工作的，所以我决定先集中在一件事情上，如果我一开始先破坏某件事的习惯，它就会扩展到整个公司。&lt;/p&gt;

&lt;p&gt;一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，他们就是核心习惯。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;干货&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;全书觉得最有用的就是最后的“读者实践指南”。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变可能不是很快，而且也不容易，但只要愿意付出时间去坚持，几乎所有习惯都可以改变。&lt;/p&gt;

&lt;p&gt;理解框架&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.找出惯常行为
2.用各种奖赏进行试验
3.将暗示隔离出来
4.制订计划
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然改变习惯很难，但这个框架是一个好的开端。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;自律+坚持&lt;/h4&gt;

&lt;p&gt;想要改变现在的生活，想要更加靠近自己的梦想，必须得改变自己的某些坏习惯，平时要严格自律，当然，坚持也是必须得。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Nov 2014 00:42:23 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/the_power_of_rabit_cn</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/the_power_of_rabit_cn</guid>
        
        
        <category>post</category>
        
        <category>习惯</category>
        
      </item>
    
      <item>
        <title>Google V8引擎的安装和使用</title>
        <description>&lt;p&gt;最近写的一个模块需要引用Google V8这个库，下面介绍如何安装和使用。（必须翻墙）&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;根据参考资料1，2，用git下载v8&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/v8/v8-git-mirror
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入这个目录，切到master分支，下周依赖库（必须翻墙）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd v8-git-mirror
git checkout master
make dependencies  // 下载依赖库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果成功把依赖都编译好了可以跳过下面这不，我是先在makefile里面把依赖库一个个下载回来再放在合适的目录
,makefile 里面列出的依赖库如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;493     svn checkout --force http://gyp.googlecode.com/svn/trunk build/gyp \
494         --revision 1831
495     if svn info third_party/icu 2&amp;gt;&amp;amp;1 | grep -q icu46 ; then \
496       svn switch --force \
497           https://src.chromium.org/chrome/trunk/deps/third_party/icu52 \
498           third_party/icu --revision 277999 ; \
499     else \
500       svn checkout --force \
501           https://src.chromium.org/chrome/trunk/deps/third_party/icu52 \
502           third_party/icu --revision 277999 ; \
503     fi
504     svn checkout --force http://googletest.googlecode.com/svn/trunk \
505         testing/gtest --revision 692
506     svn checkout --force http://googlemock.googlecode.com/svn/trunk \
507         testing/gmock --revision 485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;东西准备好了，下面编译这个库，注意把ibrary=shared 参数加上，把它编译为so库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make native mode=debug library=shared -j2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定native会自动判断你当前系统的架构进行编译，-j2为指定使用2个进程进行编译加快编译速度,编译成功后在v8-git-mirror/out/native/lib.target目录下会出现下面几个文件，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-rwxr-xr-x. 2 root root  2742392 11月  9 11:31 libicui18n.so
-rwxr-xr-x. 2 root root 12400430 11月  9 11:30 libicuuc.so
-rwxr-xr-x. 2 root root 12227393 11月  9 11:45 libv8.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式和一般的so一样（可以将so拷贝到系统lib目录或者指定LD_LIBRARY_PATH环境变量）.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;参考资料中的第三项，将提供代码（可能和下面的有所差别）保存为hw.cc&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;#include &amp;lt;v8.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a new Isolate and make it the current one.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isolate_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a stack-allocated handle scope.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;HandleScope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a new context.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;  		&lt;span class=&quot;c1&quot;&gt;// Enter the context for compiling and running the hello world script.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scope&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context_scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Create a string containing the JavaScript source code.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewFromUtf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isolate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;#39;Hello&amp;#39; + &amp;#39;, World!&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Compile the source code.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Run the script to get the result.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;Local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;   		&lt;span class=&quot;c1&quot;&gt;// Convert the result to an UTF8 string and print it.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Utf8Value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;   		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;   		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++ -I/root/sources/v8-git-mirror/include hw.cc -lv8 -lpthread -o hw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./hw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello，world！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就算是使用了v8这个库了，里面的代码理解需要了解v8的基本数据结构和原理，上面例子虽然就几行代码，但五脏俱全，算是个小小的将js代码进行解释的程序了。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考资料&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;[1] https://code.google.com/p/v8-wiki/wiki/UsingGit
[2] https://github.com/v8/v8-git-mirror
[3] https://developers.google.com/v8/get_started
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 10 Nov 2014 01:21:11 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/google_v8_install</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/google_v8_install</guid>
        
        
        <category>post</category>
        
        <category>google</category>
        
        <category>v8</category>
        
      </item>
    
      <item>
        <title>关于Node Buffer对象</title>
        <description>&lt;p&gt;最近写一个专门为新项目写一个nodejs的c++模块去解释protobuf的消息（名字叫node_pd哈，后面写文章介绍），为何要重新造轮子？因为npm上面都TM没有合适的，试用了两个，一个不支持extension，一个extension解释出问题，然后，然后就打算自己写了，目前准备完成了，90%吧，可以正常在C++和javascript之间解释和生成消息，呃。。。，说了些和主题木有关系东东，算是作为背景吧。&lt;/p&gt;

&lt;p&gt;Node提高的buffer对象，实际上是一个二进制数组，占用的内存使用堆分配，没有使用V8的垃圾回收机制。这个对象所在的模块由node启动的时候加载，不需要required，可以直接使用，一般使用buffer对象来存储二进制数据，多用于网络服务作为缓冲区，好吧，我承认这几句话很废。&lt;/p&gt;

&lt;p&gt;node的buffer对象使用的内存不在v8引擎的管理，是存在于v8内存管理之外的内存空间，代码头文件解释是这么说的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A buffer is a chunk of memory stored outside the V8 heap, mirrored by an object in javascript.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看下代码：node-v0.10.32/src/node_buffer.cc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;111 Buffer* Buffer::New(char *data, size_t length,
112                     free_callback callback, void *hint) {
113   HandleScope scope;
114
115   Local&amp;lt;Value&amp;gt; arg = Integer::NewFromUnsigned(0);
116   Local&amp;lt;Object&amp;gt; obj = constructor_template-&amp;gt;GetFunction()-&amp;gt;NewInstance(1, &amp;amp;arg);
117
118   Buffer *buffer = ObjectWrap::Unwrap&amp;lt;Buffer&amp;gt;(obj);
119   buffer-&amp;gt;Replace(data, length, callback, hint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看最后一句，以及下面的最后一句，确实是在系统堆中分配，不在v8的管理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;162 void Buffer::Replace(char *data, size_t length,
163                      free_callback callback, void *hint) {
164   HandleScope scope;
174   length_ = length;
175   callback_ = callback;
176   callback_hint_ = hint;
177
178   if (callback_) {
179     data_ = data;
180   } else if (length_) {
181     data_ = new char[length_];
182     if (data)
183       memcpy(data_, data, length_);
189   handle_-&amp;gt;SetIndexedPropertiesToExternalArrayData(data_,
190                                                    kExternalUnsignedByteArray,
191                                                    length_);
192   handle_-&amp;gt;Set(length_symbol, Integer::NewFromUnsigned(length_));
193 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且会将内存指针设置在handle_这个v8对象（这是个持久型对象）上面,说白了就是把地址放在这个对象中，。当需要在引用这个buffer对象的数据时，在v8环境中就可以根据这个handle_去获取数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;75   static inline char* Data(v8::Handle&amp;lt;v8::Value&amp;gt; val) {
 	76     assert(val-&amp;gt;IsObject());
 	77     void* data = val.As&amp;lt;v8::Object&amp;gt;()-&amp;gt;GetIndexedPropertiesExternalArrayData();
 	78     return static_cast&amp;lt;char*&amp;gt;(data);
 	79   }
 	80
 	81   static inline char* Data(Buffer *b) {
 	82     return Buffer::Data(b-&amp;gt;handle_);
 	83   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便说下，buffer的对象最大的理论存储空间为0x3fffffff，也就是1G空间。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;66 class NODE_EXTERN Buffer: public ObjectWrap {
 	67  public:
 	68   // mirrors deps/v8/src/objects.h
 	69   static const unsigned int kMaxLength = 0x3fffffff;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;关于使用&lt;/h4&gt;
&lt;p&gt;如果想在node c++模块中使用buffer对象，需要引入buffer和node对象wrapper的头文件（node.h，node_buffer.h，node_object_wrap.h）。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;后话&lt;/h4&gt;
&lt;p&gt;详细使用待研究。。。。。&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Nov 2014 06:18:00 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/node-buffer</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/node-buffer</guid>
        
        
        <category>node</category>
        
        <category>c/c++</category>
        
        <category>buffer</category>
        
        <category>v8</category>
        
      </item>
    
      <item>
        <title>大型网站架构基础</title>
        <description>&lt;pre&gt;&lt;code&gt;上周读了《大型网站技术架构》这本书，总体来说，里面很多重复的内容，而且讲的不够深入，很多都是简单介绍一下，大型网站架构也不是一开始就设置的多么高级，也是由于网站性能，可用性等满足不了当前的情况进而对站点架构进行升级，改正的过程，书里面讲到几个平时比较混淆的概念，这篇就作为读书比较记录下书中想过概念和技术。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;大型网站架构普遍的演变过程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.应用程序和DB在同一台服务器
2.应用程序和DB分离
3.应用程序和DB之间假如缓存层，可以为本地缓存或者为远程缓存（memcached，redis等）
4.使用lVS+应用程序集群替换单个应用程序改善网站的并发处理能力
5.数据库改造，数据库读写分离（主-从模式）
6.在LVS前面，增加反向代理和CDN加速网站响应速度
7.数据库改造，分库，分表，建立分布式数据库集群
8.应用程序集群升级为分布式服务
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;大型网站架构模式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1.分层：网站分为应用层，服务层，数据层
2.分割：业务分割部署，功能分割为多个服务
3.分布式：
		&amp;lt;1&amp;gt;分布式应用和服务：应用和服务模块分布式部署
		&amp;lt;2&amp;gt;分布式静态资源，网站的css，js和图片进行独立部署
		&amp;lt;3&amp;gt;分布式数据和存储，数据分布式存储
		&amp;lt;4&amp;gt;分布式技术，hadoop和MapReduce进行批处理计算，分散计算
		&amp;lt;5&amp;gt;分布式配置和锁，zookeeper
4.集群：无状态服务集群部署
5.缓存，加快处理速度，例如，CDN，反向代理，本地缓存，分布式缓存
6.异步，加快响应，消除并发高峰
7.冗余，冷备份和热备份
8.自动化，部署自动化
9.安全，防XSS和SQL注入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;软件架构关注的几个要素：性能，可用性，伸缩性，扩展性，安全性。&lt;/h4&gt;

&lt;h4 id=&quot;section-3&quot;&gt;性能&lt;/h4&gt;
&lt;p&gt;主要使用响应速度作为指标，可以使用页面压缩，合理页面布局，减少COOKIE传输，CDN，反向代理，缓存，SQL优化，索引，读写分离，集群，异步等手段进行各层次优化。&lt;/p&gt;

&lt;p&gt;Web前端优化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.减少http请求数量（压缩js，css，和图片合并）
2.浏览器缓存
3.启用压缩，服务器对文件进行压缩
4.css放页面head，js放body里面
5.减少cookies传输
6.CDN加速
7.反向代理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后端服务器优化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.分布式缓存，memcache，redis
2.代码异步，无状态
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;可用性&lt;/h4&gt;
&lt;p&gt;主要使用可用时间作为指标，可以使用热备份，主从DB，无状态应用集群部署等手段提高。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;伸缩性&lt;/h4&gt;
&lt;p&gt;衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器，加入新的服务器后，是否可以提供和原来服务器无差别的服务，集群中可容纳的总的服务器数量是否有限制。
应用服务器集群，尽量让服务无状态以通过LVS不断加入服务器
缓存服务器集群，加入新的服务器会领缓存失效，使用一致性hash最大限度减少失效的节点（虚拟节点）&lt;/p&gt;

&lt;p&gt;伸缩性设计&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.http重定向负载均衡
2.DNS域名解析负载均衡
3.方向代理
4.IP负载均衡
5.数据链路负载均衡（lvs）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-6&quot;&gt;扩展性&lt;/h4&gt;
&lt;p&gt;衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现在产品透明无影响，不需要修改或者修改很少业务功能就可以上线新产品，不同产品之间尽量减少耦合，主要手段是使用事件驱动架构和分布式服务。&lt;/p&gt;

&lt;p&gt;利用分布式消息队列降低系统耦合性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.事件驱动架构（libevent，node等）
1.分布式消息队列（rabbitmq等）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-7&quot;&gt;安全性&lt;/h4&gt;
&lt;p&gt;是否能保护网站重要数据不被窃取。&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Oct 2014 08:37:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/web_server_architecture</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/web_server_architecture</guid>
        
        
        <category>post</category>
        
        <category>web</category>
        
        <category>architecture</category>
        
      </item>
    
      <item>
        <title>Rework2 - office not required (重来2)</title>
        <description>&lt;p&gt;最近看rework - office not required 这本书，里面介绍了几个远程工作的工具和建议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.远程工作相互重叠的时间，37signals建议4小时。：）
2.屏幕共享软件：
	MAC中的quicktime player 屏幕录制
	www.join.me
	http://www.gotomeeting.com/
	http://www.webex.com/

3.资料共享
	dropbox，github，共享日历，共享工作任务todo list
	http://www.salesforce.com/ 或者 https://highrisehq.com/ 跟进销售
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是否远程工作，在每天结束之后，问问自己，今天有木有好好工作？这个问题可以让你内心得到解脱，如果你迅速地答出，是的，你就可以心满意足地停下来，就算这项工作木有完成，这也许就是一种心里暗示，我有时候也会感受到，确定是有效果的。&lt;/p&gt;

&lt;p&gt;高效获取市场的几个策略&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.在销售阶段，要让潜在客户很早就知道你们不在同一个地方，信任需要在一开始的时候就建立起来。
2.在客户开口索要你的背景资料之前，就主动给他们，一上来就让客户知道，你没什么隐瞒的。
3.经常把工作进度拿给他们看，客户会焦虑，而这是减轻焦虑的好方法。
4.让客户很容易就找到你，既然你们没法面对面，那你最好迅速地回电话，邮件和即时信息。
5.要让客户参与进来，及时掌握进度，让客户感受到，这也是他们的项目。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了顺利地实现远程工作，你的写作能力和沟通能力一定要过硬，熟练掌握英文是关键。&lt;/p&gt;

&lt;p&gt;优秀的远程员工就是优秀的员工。&lt;/p&gt;

&lt;p&gt;把一天分成几个阶段，阅读最新的资讯，协作，专心工作，处理邮件，查看行业新闻等。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Oct 2014 09:28:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/rework2_remoting_work</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/rework2_remoting_work</guid>
        
        
        <category>post</category>
        
        <category>reading</category>
        
      </item>
    
      <item>
        <title>一致性Hash</title>
        <description>&lt;pre&gt;&lt;code&gt;去年工作的时候听大智慧的架构师的演讲，第一次听到一致性hash这个名词，当时没听明白，
后面工作没联系到这个东西，后来也没去追查了，但了今年，听存储的同事的演讲，
也听到这个名词，然后就有了这篇文章。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;背景&lt;/h4&gt;

&lt;p&gt;一般的分布式缓存系统是这样设计的，有好几台内存比较大的服务器作为缓存服务器，
假如3台，node1，node2，node3，业务程序需要把频繁访问的热点数据存储在
缓存服务器中以减少对下层DB的压力，这时，假如写数据（“test”，”{a:1,b:2}”）
, 缓存系统内部的过程是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.向缓存系统的路由组件根据hash算法，算出key（也就是text）的hash值，
然后用这个hash值余3的出一台缓存服务器，假如这里得到node2
2.缓存系统将这个路由信息记录下来，以便下次访问
3.返回给业务程序node2这个节点的信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，业务程序就把这个数据往node2这个节点写（至于用什么协议，可以自定，
假如Memcached，redis等），下次需要读取数据的时候，读操作过程简单可以认为是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.根据key从缓存系统的路由组件获取这个key对应的node节点信息
2.返回给业务程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以马上知道是node2这个节点，立刻进行读操作，无需再访问DB，起到加速的作用。
但后面业务发展迅猛，需要增加了1台缓存服务器，这时，缓存服务器的数量就变成4了，
路由计算也需要使用4昨晚被除数重算计算hasn值，这样前面三台缓存服务器的路由信息就
起不到原来的左右，所有数据都会走到DB去访问并重新缓存，起不到原来需要的效果。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;那有什么方法可以处理尼？&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;本质上就是需要在新增服务器的时候尽量减少对已上线服务器的影响，也就是尽量
减少路由信息失效的范围
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;hashconsistent-hashing&quot;&gt;一致性hash（Consistent hashing）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;答案就是引入一致性hash算法来做路由计算，先构造一个0-2的32次方的环，然后
将缓存服务器id（假如cache A）根据hash算出一个数值，这个数值也是0-2的32次方
的范围，并投射在这个环上，类似，cache B 和cache C同样用这个方式投射到这个大环
上面，当业务程序需要把写缓存数据时，讲key进行hash得到一个0到2的32次方之间的
hash值（key 1），并投射到这个环上面，然后顺时针找到cache A，因此就返回cache A
的信息，这样的做法的好处时，下次有新服务器加入时，例如cache D，计算得出的hash值
投放到cache A 和 cache B直接，那么原来在cache A到cache b直接的某一部分
（cache A到cache D的这部分）路由信息会失效，而其他的别的路由信息都可以继续
正常使用，但这样由于新增的服务器减低了cache B的负载（一部分负载都到cache D了），
而cache A和cache C的负载还是很高，这样所有服务器的负载就很不平衡，因此我们采取
下面的方式进一步优化这个方案。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://feeds.feedburner.com/Dhclavie/images/Consistent_hashing.jpg&quot; alt=&quot;Consistent_hashing&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;虚拟节点&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;上面提到的不足的主要原因是因为节点数量在比较少的情况下才会发生的，因此下面的
解决方案是增加缓存服务器的节点数量，但服务器非常昂贵，增加是非常有限的，因此
现在的方案是把一个物理节点虚拟为多个虚拟节点，如下图，新增服务器时，都按照这样
的方式，把虚拟节点映射到hash环上面去，这样hash key的值分布就会比较均很到散落
在这些物理服务器上面去。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://feeds.feedburner.com/Dhclavie/images/Consistent_hashing_virtual_node.png&quot; alt=&quot;Consistent_hashing&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Oct 2014 08:40:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/consistent_hashing</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/consistent_hashing</guid>
        
        
        <category>post</category>
        
        <category>consistenthashing</category>
        
        <category>cache</category>
        
      </item>
    
      <item>
        <title>Apple Swift Language Base</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.变量和常量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let定义常量，var定义变量	
赋值市会隐含定义类型，swift不会隐含修改变量的类型，需要修改，必须明确指定。
字符串拼接使用加号（+），或者直接在字符串字面量前面使用\() 
创建数组或者字典使用[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.控制流&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;条件控制 if switch， switch 里面的case无需明确break，默认会break，但必须有default
循环使用for, for in , while , do while
使用..&amp;lt; 或者...在循环中指定一个范围，后者为包括
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.函数和闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;函数使用func定义，可以返回多个值，函数调用使用括号，参数必须指定类型
func(a:Int  , b:Int ) -&amp;gt; String {} 接受2个int类型，返回一个字符串
函数参数可以为可变参数，在类型后面加...
函数体可以继续定义函数
在swift，函数本质上是一个简单的闭包
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;4.对象和类&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class 后面接类名定义类
使用类名+括号创建对象，调用对象方法使用.操作符
构成函数使用init定义
析构函数使用deinit定义
在类函数里使用self访问对象成员
继承使用:
重写子类方法使用override指定
属性可以具有set，get方法，set方法默认传递的参数名称为newValue，可以修改，在set后面加括号指明参数名称即可，无	需指定类型
可以给属性添加willSet和didSet指定赋值前或者赋值后的逻辑
可以配合？指定选项变量，当对象为nil时，语句后面的操作不会执行
选项变量为在变量类型前面加？，定义为选项变量，后面引用都比较有？号
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;5.结构和枚举类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;enum定义枚举类型，可以为enum类型提高函数，但这里的枚举类型不需要值，c/c++中的枚举类型本质为unsigned，
但这里的枚举类型为一个名称，我想应该是一种对象吧。可以在里面定义方法，并进行访问，而且枚举类型和类不一样，
不需要实例化。

struct定义结构，结构可以定义构造函数和方法，属性，但和类不一样的是结构使用值传递，类使用引用传递，这个
和传统语言类似
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;protocolsextensions&quot;&gt;6.协议和扩展（protocols，extensions）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用protocol定义一个协议,协议里面的只可以写方法声明或者属性声明，不能写body
mutating func定义个协议方法，也就是定义一个接口吧，继承者必须实现。	使用extension扩展一个存在的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;generics&quot;&gt;7.Generics（怎么叫？应该是模板吧）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用&amp;lt;&amp;gt;指定类型，具体使用case by case
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 19 Oct 2014 08:53:20 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/apple_swift_language_base</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/apple_swift_language_base</guid>
        
        
        <category>post</category>
        
        <category>swift</category>
        
        <category>apple</category>
        
      </item>
    
      <item>
        <title>Base Javascript</title>
        <description>&lt;p&gt;1.访问一个不存在的变量或者没有赋值的变量，得到undefined&lt;/p&gt;

&lt;p&gt;2.null变量不是undefined，这个变量有值，是一个特殊的object，值为为null&lt;/p&gt;

&lt;p&gt;3.任何不属于number，string，boolean，undefined，null的都为对象object（function也为对象）&lt;/p&gt;

&lt;p&gt;4.typeof 操作可以返回变量的类型,用字符串表示，如“string”&lt;/p&gt;

&lt;p&gt;5.NaN is a special value that is also a number，Nan也是一个数值&lt;/p&gt;

&lt;p&gt;6.下面的情况导致false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The empty string “”&lt;/li&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;The number 0&lt;/li&gt;
  &lt;li&gt;The number NaN&lt;/li&gt;
  &lt;li&gt;The Boolean false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7.函数没有明确返回值，默认返回undefined&lt;/p&gt;

&lt;p&gt;8.函数里面包含一个默认的数组arguments（其实是一个object）包含所有的参数&lt;/p&gt;

&lt;p&gt;9.if内定义的变量外层可以访问，函数内定义的变量外层不能访问&lt;/p&gt;

&lt;p&gt;10.Variable hoisting, 函数内定义的和外层变量同名的变量，定义会被提升到函数开始，因此，一进入函数内，和函数内部同名的外部变量瞬间被秒杀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When your JavaScript program execution enters a new function, 
all the variables declared anywhere in the function are 
moved (or elevated, or hoisted) to the top of the function. 
This is an important concept to keep in mind. Further, 
only the declaration is hoisted, meaning only the presence of 
the variable is moved to the top. Any assignments stay where they are.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;      	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;     	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变成:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;      	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// same as: var a = undefined;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt;      	&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;11.即刻执行的函数不能被执行第二次！！！&lt;/p&gt;

&lt;p&gt;12.函数可以被作为参数转递&lt;/p&gt;

&lt;p&gt;13.闭包说白了就是将变量作用域的范围进行扩大&lt;/p&gt;

&lt;p&gt;14.给对象设置属性时，属性的名字可以为下面形式：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;occupation&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;    	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;occupation&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;15.在javascript中如果你想使用类似hash的数据结构，那么可以使用object&lt;/p&gt;

&lt;p&gt;16.创建“new 函数名称”的形式可以创建一个对象，并且会调用这个函数，而这个函数也就成为了这个对象的构造函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance_dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;keke&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17.每个object实例都有一个constructor属性，指向这个实例的构造函数&lt;/p&gt;

&lt;p&gt;18.函数有一个length属性指出期望的参数个数（也就是参数列表的个数）&lt;/p&gt;

&lt;p&gt;19.每个函数都有一个prototype属性，这个属性指向一个对象，每个从这个函数构造出来的对象都继续了这个prototype所指向的对象的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;All objects created with this function keep a reference 
to the prototype property and can use its properties as their own
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20.function对象的call和apply方法可以用别的对象作为调用实例进行使用，也就是可以使用别的实例作为内部的this引用进行使用，功能一样，但传递的参数不一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;These methods also allow your objects to &quot;borrow&quot; methods 
from other objects and invoke them as their own. 
This is an easy and powerful way to reuse code.

some_obj.someMethod.apply(my_obj, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
   	some_obj.someMethod.call(my_obj, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21.当对象是new 函数的方式构造出来的，prototype上面的属性才会依附到this上面，单纯使用函数调用，prototype上面的属性不会依附到this对象，因此，通过在prototype上面添加属性的方式，可以给实例进行属性添加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Adding methods and properties to the prototype property 
of the constructor function is another way to add functionality 
to the objects this constructor produces.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;22.属性查找时是按照prototype链往上查找。&lt;/p&gt;

&lt;p&gt;23.prototype依附的属性会在new操作之后拷贝到对象上面，对对象属性的修改不会影响到prototype上面的属性。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Oct 2014 07:40:33 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/Javascript-base</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/Javascript-base</guid>
        
        
        <category>post</category>
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>Node Module</title>
        <description>&lt;p&gt;这篇文章介绍如何编写Node模块，node模块遵循commonjs标准，实现起来非常简单，下面简单实现一个maths的模块, 在macosx下编写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim maths.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在maths.js里面写入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.add = function(a, b) {
	return a+b;
}
exports.sub = function(a, b) {
	return a-b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到代码里面使用了exports导出两个函数，在node里面使用exports或者module.exports导出模块里面的功能，现在，已经完成了maths模块，下面试着使用下这个模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在相同目录下创建app.js，然后写入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var maths = require(&quot;/maths.js&quot;);
console.log(maths(1,2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 但注意到我们引入这个模块的形式指明了路径，如何才可以使用npm安装我们自己编写的模块？现在，我们创建一个maths的目录：

mkdir maths
cd maths
mv ../maths.js index.js
vim package.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在package.json里面写入下面参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  		&quot;name&quot;: &quot;maths&quot;,
  		&quot;version&quot;: &quot;0.0.1&quot;,
  		&quot;private&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意version参数必须是三位的，之前我使用了2位的，模块没有包装成功，最后创建README.md文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo maths function add and sub! &amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我们使用下面命令包装模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/maths/ npm pack
	maths-0.0.1.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块已经打包完成，下面试着用npm安装这个模块到我们的项目里面（下面创建一个项目目录，进行模块安装）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir modtest
cd modtest
npm install ~/Project/maths/maths-0.0.1.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在模块已经安装到我们的项目里面，可以查看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ npm install ~/Project/maths/maths-0.0.1.tgz
	maths@0.0.1 node_modules/maths
 ~/Project/modtest/ ls
	node_modules
 ~/Project/modtest/ ls node_modules
	maths
 ~/Project/modtest/ ls node_modules/maths
	README.md    index.js     package.json
 ~/Project/modtest/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们试着来使用这个模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var maths = require(&quot;maths&quot;);
console.log(maths.add(1,2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ node app.js
	3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的一个模块完成拉 ：），但看见很多别的人模块里面导出功能是使用module.exports的，我们这里使用了exports，到底这两个有什么差别？看下面的例子,编辑文件test.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = &quot;xxxxxxxx&quot;;
exports.add = function(){
	console.log(&quot;add&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用这个文件时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = &quot;xxxxxxxx&quot;;
exports.add = function(){
      console.log(&quot;add&quot;);
}
                    
 ~/Project/modtest/ node app.js
	xxxxxxxx
	/Users/apple/Project/modtest/app.js:4
	test.add();
 		 ^
	TypeError: Object xxxxxxxx has no method &#39;add&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的test对象为一个string，没有add方法，再看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports.name = &quot;xxxxxxxx&quot;;
exports.add = function(){
	console.log(&quot;add&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入这个文件时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var test = require(&quot;./test.js&quot;);
console.log(test.name);
test.add();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~/Project/modtest/ node app.js
xxxxxxxx
add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，我们可以得知，最终导出的是modul.exports上面的对象，attach在exports上面的对象最终会被attach到modul.exports上面，但前提是module.exports是一个对象。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Sep 2014 19:09:08 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/node-module</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/node-module</guid>
        
        
        <category>post</category>
        
        <category>node</category>
        
        <category>module</category>
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>Git Base</title>
        <description>&lt;h4 id=&quot;gitgit&quot;&gt;假设你已经安装了git，下面是一下git的基本配置和操作，每次做一个项目都网上找一遍，这次写在这里，下次不用找了:)&lt;/h4&gt;

&lt;h5 id=&quot;section&quot;&gt;初始化一个项目&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-1&quot;&gt;设置提交和修改的作者信息&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;John Doe&quot;
git config --global user.email &quot;John@xxx.com&quot;
其中--global 可以设置为--system, --global or --file，范围影响为从整个系统，当前账户，和当前项目
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;logstatus&quot;&gt;设置log和status的颜色高亮&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --global color.ui true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;commit&quot;&gt;设置commit时使用的编辑器&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --global core.editor vim 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-2&quot;&gt;设置解决合并冲突时使用哪种差异分析工具&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --global merge.tool vimdiff
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;设置命令别名，修改为个人喜好，&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --global alias.co checkout
git config --global alias.cm commit
git config --global alias.st status
git config --global alias.br branch
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-4&quot;&gt;查看配置信息&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;git-&quot;&gt;将文件添加到git 库&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git add
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;commit-1&quot;&gt;添加commit&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git commit
git commit -am &quot;comm内容&quot; 添加文件和commit一并完成
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-5&quot;&gt;创建分支&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git branch branch-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-6&quot;&gt;切换分支&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git checkout branch-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-7&quot;&gt;将当前项目和一个远程库关联&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://xxxxxx/xxxx.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-8&quot;&gt;讲一个本地分支和一个远程库关联&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;git push -u origin branch-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;gitignore&quot;&gt;创建.gitignore文件屏蔽不需要管理的文件或者自动生成的文件&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;例如：下面为忽略所有so和o文件
	*.so
	*.o
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 25 Sep 2014 19:30:23 +0800</pubDate>
        <link>http://feeds.feedburner.com/Dhclavie//blog/git-base</link>
        <guid isPermaLink="true">http://feeds.feedburner.com/Dhclavie//blog/git-base</guid>
        
        
        <category>post</category>
        
        <category>base</category>
        
        <category>git</category>
        
      </item>
    
  </channel>
</rss>
